diff -urN -x '*.json' esp32s3_xbox_adapter-master/main/CMakeLists.txt esp32s3/main/CMakeLists.txt
--- esp32s3_xbox_adapter-master/main/CMakeLists.txt	2024-07-07 16:29:35.000000000 +0800
+++ esp32s3/main/CMakeLists.txt	2026-02-02 11:18:16.000000000 +0800
@@ -1,10 +1,7 @@
-set(srcs "esp_hid_host_main.c"
-         "esp_hid_gap.c"
-	 "hid_ps4_driver.c")
-set(include_dirs ".")
-
-idf_component_register(SRCS "${srcs}"
-                       INCLUDE_DIRS "${include_dirs}"
-                       REQUIRES driver esp_hid mbedtls esp_timer
-                       PRIV_REQUIRES nvs_flash
-		       EMBED_TXTFILES "key.pem" "serial.txt" "sig.bin")
+idf_component_register(
+    SRCS "esp_hid_host_main.c" "esp_hid_gap.c" "hid_ps4_driver.c"
+    INCLUDE_DIRS "."
+    REQUIRES driver esp_hid mbedtls esp_timer
+    PRIV_REQUIRES bt esp_hid driver esp_tinyusb led_strip nvs_flash
+    EMBED_TXTFILES "key.pem" "serial.txt" "sig.bin"
+)
diff -urN -x '*.json' esp32s3_xbox_adapter-master/main/esp_hid_host_main.c esp32s3/main/esp_hid_host_main.c
--- esp32s3_xbox_adapter-master/main/esp_hid_host_main.c	2024-07-07 16:29:35.000000000 +0800
+++ esp32s3/main/esp_hid_host_main.c	2026-02-09 14:30:18.000000000 +0800
@@ -11,6 +11,7 @@
 #include "freertos/FreeRTOS.h"
 #include "freertos/task.h"
 #include "freertos/event_groups.h"
+#include "freertos/timers.h"
 #include "esp_system.h"
 #include "esp_wifi.h"
 #include "esp_event.h"
@@ -29,6 +30,12 @@
 #include "esp_hidh.h"
 #include "esp_hid_gap.h"
 #include "esp_timer.h"
+
+// LED Strip
+#include "led_strip.h"
+#include "driver/gpio.h"
+
+
 static const char *TAG = "xbox";
 
 #define XBOX_CONTROLLER_INDEX_BUTTONS_DIR 12
@@ -36,7 +43,33 @@
 #define XBOX_CONTROLLER_INDEX_BUTTONS_CENTER 14
 #define XBOX_CONTROLLER_INDEX_BUTTONS_SHARE 15
 
+// GPIO for WS2812 LED
+#define LED_GPIO 48
+#define LED_NUM 1
+#define LED_BRIGHTNESS_FACTOR 0.5  // 50% brightness
+
+// GPIO for boot button
+#define BOOT_BUTTON_GPIO 0  // Usually GPIO 0 is the boot button on ESP32-S3
+
+// Battery level ranges for color mapping
+typedef enum {
+    BATTERY_LEVEL_ORANGE = 0,   // [0, 5]
+    BATTERY_LEVEL_PURPLE,       // (5, 25]
+    BATTERY_LEVEL_RED,          // (25, 45]
+    BATTERY_LEVEL_YELLOW,       // (45, 65]
+    BATTERY_LEVEL_BLUE,         // (65, 85]
+    BATTERY_LEVEL_GREEN         // (85, 100]
+} battery_level_t;
+
+// Global variables for LED control
+static led_strip_handle_t led_strip;
+static bool led_initialized = false;
+static battery_level_t last_battery_level = -1;  // Initialize to invalid value
+static bool first_battery_event = true;  // Track if it's the first battery event
+static bool button_pressed = false;  // Track button state
 
+// Timer for LED control
+static TimerHandle_t led_timer = NULL;
 
 //static const uint16_t maxJoy = 0xffff;
 
@@ -46,6 +79,137 @@
 hid_ps4_report_t ps4_report = {};
 
 
+// Function to determine battery level based on percentage
+battery_level_t get_battery_level(uint8_t battery_percentage) {
+    if (battery_percentage <= 5) {
+        return BATTERY_LEVEL_ORANGE;
+    } else if (battery_percentage <= 25) {
+        return BATTERY_LEVEL_PURPLE;
+    } else if (battery_percentage <= 45) {
+        return BATTERY_LEVEL_RED;
+    } else if (battery_percentage <= 65) {
+        return BATTERY_LEVEL_YELLOW;
+    } else if (battery_percentage <= 85) {
+        return BATTERY_LEVEL_BLUE;
+    } else {
+        return BATTERY_LEVEL_GREEN;
+    }
+}
+
+// Function to get RGB values for each battery level with reduced brightness
+void get_rgb_for_battery_level(battery_level_t level, uint32_t *red, uint32_t *green, uint32_t *blue) {
+    // Full brightness values
+    switch (level) {
+        case BATTERY_LEVEL_ORANGE:
+            *red = 255 * LED_BRIGHTNESS_FACTOR;   // Orange: (255, 165, 0) -> (128, 82, 0)
+            *green = 165 * LED_BRIGHTNESS_FACTOR;
+            *blue = 0 * LED_BRIGHTNESS_FACTOR;
+            break;
+        case BATTERY_LEVEL_PURPLE:
+            *red = 128 * LED_BRIGHTNESS_FACTOR;   // Purple: (128, 0, 128) -> (64, 0, 64)
+            *green = 0 * LED_BRIGHTNESS_FACTOR;
+            *blue = 128 * LED_BRIGHTNESS_FACTOR;
+            break;
+        case BATTERY_LEVEL_RED:
+            *red = 255 * LED_BRIGHTNESS_FACTOR;   // Red: (255, 0, 0) -> (128, 0, 0)
+            *green = 0 * LED_BRIGHTNESS_FACTOR;
+            *blue = 0 * LED_BRIGHTNESS_FACTOR;
+            break;
+        case BATTERY_LEVEL_YELLOW:
+            *red = 255 * LED_BRIGHTNESS_FACTOR;   // Yellow: (255, 255, 0) -> (128, 128, 0)
+            *green = 255 * LED_BRIGHTNESS_FACTOR;
+            *blue = 0 * LED_BRIGHTNESS_FACTOR;
+            break;
+        case BATTERY_LEVEL_BLUE:
+            *red = 0 * LED_BRIGHTNESS_FACTOR;     // Blue: (0, 0, 255) -> (0, 0, 128)
+            *green = 0 * LED_BRIGHTNESS_FACTOR;
+            *blue = 255 * LED_BRIGHTNESS_FACTOR;
+            break;
+        case BATTERY_LEVEL_GREEN:
+            *red = 0 * LED_BRIGHTNESS_FACTOR;     // Green: (0, 255, 0) -> (0, 128, 0)
+            *green = 255 * LED_BRIGHTNESS_FACTOR;
+            *blue = 0 * LED_BRIGHTNESS_FACTOR;
+            break;
+        default:
+            // Default to red if invalid level
+            *red = 255 * LED_BRIGHTNESS_FACTOR;
+            *green = 0 * LED_BRIGHTNESS_FACTOR;
+            *blue = 0 * LED_BRIGHTNESS_FACTOR;
+            break;
+    }
+    
+    // Round to nearest integer
+    *red = (uint32_t)(*red + 0.5);
+    *green = (uint32_t)(*green + 0.5);
+    *blue = (uint32_t)(*blue + 0.5);
+}
+
+// LED timer callback to turn off the LED after 300ms
+void led_timer_callback(TimerHandle_t xTimer) {
+    if (led_initialized) {
+        // Turn off the LED
+        led_strip_set_pixel(led_strip, 0, 0, 0, 0);
+        led_strip_refresh(led_strip);
+    }
+}
+
+// Function to trigger LED with specific color for 300ms
+void trigger_led_with_color(uint32_t red, uint32_t green, uint32_t blue) {
+    if (led_initialized) {
+        // Set the LED to the specified color
+        led_strip_set_pixel(led_strip, 0, (uint8_t)red, (uint8_t)green, (uint8_t)blue);
+        led_strip_refresh(led_strip);
+        
+        // Restart the timer to turn off the LED after 300ms
+        if (led_timer != NULL) {
+            xTimerStop(led_timer, 0);
+            xTimerStart(led_timer, 0);
+        }
+    }
+}
+
+// ISR-safe version of trigger_led_with_color
+void trigger_led_with_color_isr_safe(uint32_t red, uint32_t green, uint32_t blue) {
+    if (led_initialized) {
+        // Set the LED to the specified color
+        led_strip_set_pixel(led_strip, 0, (uint8_t)red, (uint8_t)green, (uint8_t)blue);
+        led_strip_refresh(led_strip);
+        
+        if (led_timer != NULL) {
+            BaseType_t xHigherPriorityTaskWoken = pdFALSE;
+            
+            // Use timer API safe for ISR context
+            xTimerStopFromISR(led_timer, &xHigherPriorityTaskWoken);
+            xTimerStartFromISR(led_timer, &xHigherPriorityTaskWoken);
+            
+            // If xHigherPriorityTaskWoken was set to pdTRUE, a context switch should be requested
+            if (xHigherPriorityTaskWoken == pdTRUE) {
+                portYIELD_FROM_ISR();
+            }
+        }
+    }
+}
+
+// Function to handle battery level change
+void handle_battery_change(uint8_t battery_percentage) {
+    battery_level_t current_level = get_battery_level(battery_percentage);
+    
+    // Check if this is the first battery event or if the level has changed
+    if (first_battery_event || current_level != last_battery_level) {
+        // Update the last level
+        last_battery_level = current_level;
+        first_battery_event = false;
+        
+        // Get the RGB values for the current level
+        uint32_t red, green, blue;
+        get_rgb_for_battery_level(current_level, &red, &green, &blue);
+        
+        // Trigger the LED with the new color
+        trigger_led_with_color(red, green, blue);
+    }
+}
+
+
 void hidh_callback(void *handler_args, esp_event_base_t base, int32_t id, void *event_data)
 {
     esp_hidh_event_t event = (esp_hidh_event_t)id;
@@ -71,6 +235,10 @@
     {
         const uint8_t *bda = esp_hidh_dev_bda_get(param->battery.dev);
         ESP_LOGI(TAG, ESP_BD_ADDR_STR " BATTERY: %d%%", ESP_BD_ADDR_HEX(bda), param->battery.level);
+        
+        // Handle battery level change
+        handle_battery_change(param->battery.level);
+        
         break;
     }
     case ESP_HIDH_INPUT_EVENT:
@@ -373,6 +541,79 @@
     return ps4_desc_hid_report;
 }
 
+// GPIO interrupt handler for boot button
+static void IRAM_ATTR gpio_isr_handler(void* arg)
+{
+    uint32_t gpio_num = (uint32_t) arg;
+    if (gpio_num == BOOT_BUTTON_GPIO) {
+        button_pressed = true;
+        
+        // Get current battery level and trigger LED
+        if (!first_battery_event && last_battery_level != -1) {
+            uint32_t red, green, blue;
+            get_rgb_for_battery_level(last_battery_level, &red, &green, &blue);
+            trigger_led_with_color_isr_safe(red, green, blue);
+        }
+    }
+}
+
+// Initialize LED strip
+esp_err_t init_led_strip(void)
+{
+    // LED strip general initialization, according to your led board design
+    led_strip_config_t strip_config = {
+        .strip_gpio_num = LED_GPIO,   // The GPIO that connected to the LED strip's data line
+        .max_leds = LED_NUM,          // The number of LEDs in the strip,
+        .led_pixel_format = LED_PIXEL_FORMAT_GRB, // Pixel format of your LED strip
+        .led_model = LED_MODEL_WS2812, // LED strip model
+        .flags.invert_out = false,    // whether to invert the output signal
+    };
+
+    // LED strip backend driver initialization
+    led_strip_rmt_config_t rmt_config = {
+        .clk_src = RMT_CLK_SRC_DEFAULT,        // different clock source can lead to different power consumption
+        .resolution_hz = 10 * 1000 * 1000,   // 10MHz resolution, 1 tick = 0.1us,
+        .flags.with_dma = false,              // whether to enable the DMA feature
+    };
+
+    // Initialize the RMT channel to drive the LED strip
+    ESP_ERROR_CHECK(led_strip_new_rmt_device(&strip_config, &rmt_config, &led_strip));
+
+    // Clear the LED strip (turn off all LEDs)
+    led_strip_clear(led_strip);
+    
+    led_initialized = true;
+    
+    return ESP_OK;
+}
+
+// Initialize boot button
+esp_err_t init_boot_button(void)
+{
+    // Configure the GPIO as input
+    gpio_config_t io_conf = {
+        .pin_bit_mask = (1ULL << BOOT_BUTTON_GPIO),
+        .mode = GPIO_MODE_INPUT,
+        .pull_up_en = GPIO_PULLUP_ENABLE,  // Enable pull-up resistor
+        .pull_down_en = GPIO_PULLDOWN_DISABLE,
+        .intr_type = GPIO_INTR_NEGEDGE  // Trigger on falling edge (button pressed)
+    };
+    ESP_ERROR_CHECK(gpio_config(&io_conf));
+
+    // Install GPIO ISR service
+    // 推荐写法
+    esp_err_t err = gpio_install_isr_service(0);
+    if (err != ESP_OK && err != ESP_ERR_INVALID_STATE) {
+        return err; // 只有在真正的错误（如内存不足）时才报错
+    }
+
+    // Add ISR handler for the boot button
+    ESP_ERROR_CHECK(gpio_isr_handler_add(BOOT_BUTTON_GPIO, gpio_isr_handler, (void*)BOOT_BUTTON_GPIO));
+
+    ESP_LOGI(TAG, "Boot button initialized on GPIO %d", BOOT_BUTTON_GPIO);
+    return ESP_OK;
+}
+
 void app_main(void)
 {
     esp_err_t ret;
@@ -385,6 +626,19 @@
     }
     ESP_ERROR_CHECK(ret);
 
+    // Initialize LED strip
+    ESP_ERROR_CHECK(init_led_strip());
+    
+    // Create the timer for LED control (300ms timeout)
+    led_timer = xTimerCreate("led_timer", pdMS_TO_TICKS(300), pdFALSE, (void*)0, led_timer_callback);
+    if (led_timer == NULL) {
+        ESP_LOGE(TAG, "Failed to create LED timer");
+        return;
+    }
+
+    // Initialize boot button
+    ESP_ERROR_CHECK(init_boot_button());
+
     ps4_driver_init();
 
     ESP_LOGI(TAG, "USB initialization");
diff -urN -x '*.json' esp32s3_xbox_adapter-master/main/hid_ps4_driver.c esp32s3/main/hid_ps4_driver.c
--- esp32s3_xbox_adapter-master/main/hid_ps4_driver.c	2024-07-07 16:29:35.000000000 +0800
+++ esp32s3/main/hid_ps4_driver.c	2026-02-09 14:14:10.000000000 +0800
@@ -280,6 +280,8 @@
 extern const unsigned char ps4_signature_start[] asm("_binary_sig_bin_start");
 extern const unsigned char ps4_signature_end[] asm("_binary_sig_bin_end");
 
+// Global variable to store the converted binary serial data
+static uint8_t ps4_serial_binary[16] = {};
 
 mbedtls_pk_context pk;
 static hid_ps4_report_t last_report = {};
@@ -420,6 +422,63 @@
     return 0;
 };
 
+// Helper function to convert a hex character to its integer value
+static uint8_t hex_char_to_int(char c)
+{
+    if (c >= '0' && c <= '9') {
+        return c - '0';
+    } else if (c >= 'A' && c <= 'F') {
+        return c - 'A' + 10;
+    } else if (c >= 'a' && c <= 'f') {
+        return c - 'a' + 10;
+    }
+    return 0; // Invalid hex character
+}
+
+// Helper function to convert hex string to binary data
+static void hex_string_to_binary(const unsigned char *hex_str, size_t hex_len, uint8_t *output, size_t output_size)
+{
+    size_t output_idx = 0;
+    size_t i = 0;
+    
+    // Process the hex string in pairs of characters
+    while (i < hex_len && output_idx < output_size) {
+        // Skip non-hex characters (like spaces or newlines)
+        if (!((hex_str[i] >= '0' && hex_str[i] <= '9') || 
+              (hex_str[i] >= 'A' && hex_str[i] <= 'F') || 
+              (hex_str[i] >= 'a' && hex_str[i] <= 'f'))) {
+            i++;
+            continue;
+        }
+        
+        // Make sure we have a pair of hex characters
+        if (i + 1 < hex_len) {
+            uint8_t high_nibble = hex_char_to_int(hex_str[i]);
+            uint8_t low_nibble = hex_char_to_int(hex_str[i + 1]);
+            output[output_idx] = (high_nibble << 4) | low_nibble;
+            output_idx++;
+            i += 2; // Move to next pair
+        } else {
+            // Odd number of hex characters - treat as error, skip
+            i++;
+        }
+    }
+    
+    // If we have space left in the output buffer, pad with zeros at the beginning
+    if (output_idx < output_size) {
+        // Shift the data to the right and fill the beginning with zeros
+        size_t data_start = output_size - output_idx;
+        // Move existing data to the right
+        for (int j = output_idx - 1; j >= 0; j--) {
+            output[data_start + j] = output[j];
+        }
+        // Fill the beginning with zeros
+        for (size_t j = 0; j < data_start; j++) {
+            output[j] = 0;
+        }
+    }
+}
+
 void sign_nonce(void)
 {
 
@@ -448,7 +507,7 @@
         int offset = 0;
         memcpy(&ps4_auth_buffer[offset], nonce_signature, 256);
         offset += 256;
-        memcpy(&ps4_auth_buffer[offset], ps4_serial_start, 16);
+        memcpy(&ps4_auth_buffer[offset], ps4_serial_binary, 16);
         offset += 16;
         // mbedtls_mpi *mpi = static_cast<mbedtls_mpi *>(&rsa_context->N);
         mbedtls_mpi_write_binary(&rsa->MBEDTLS_PRIVATE(N), &ps4_auth_buffer[offset], 256);
@@ -549,6 +608,10 @@
     memset(ps4_auth_buffer, 0, sizeof(ps4_auth_buffer));
     memset(ps4_auth_nonce_buffer, 0, sizeof(ps4_auth_nonce_buffer));
 
+    // Convert hex string from serial.txt to binary and store in global variable
+    size_t serial_len = ps4_serial_end - ps4_serial_start;
+    hex_string_to_binary(ps4_serial_start, serial_len, ps4_serial_binary, 16);
+
     int ret = 0;
     mbedtls_pk_init(&pk);
     ret = mbedtls_pk_parse_key(&pk, (uint8_t *)key_pem_start, key_pem_end - key_pem_start, NULL, 0, rng, NULL);
diff -urN -x '*.json' esp32s3_xbox_adapter-master/main/idf_component.yml esp32s3/main/idf_component.yml
--- esp32s3_xbox_adapter-master/main/idf_component.yml	2024-07-07 16:29:35.000000000 +0800
+++ esp32s3/main/idf_component.yml	2026-02-02 10:55:17.000000000 +0800
@@ -1,4 +1,5 @@
 ## IDF Component Manager Manifest File
 dependencies:
   espressif/esp_tinyusb: "1.2.0"
-  idf: "^5.0"
\ No newline at end of file
+  idf: "^5.0"
+  espressif/led_strip: "^2.0.0"
